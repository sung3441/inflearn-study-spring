# API 개발 고급 정리

- 엔티티 조회
  - 엔티티를 조회해서 그래도 반환: v1
    - 엔티티를 바로 반환하는 것은 사용 x, api 스펙이 변경될 수도 있음.
  - 엔티티 조회 후 dto로 변환해서 반환: v2
    - 엔티티 스펙이 바뀌어도 api 스펙은 변경 x
    - 조인이 필요한 경우 성능 저하될 수 있음
  - 페치 조인으로 쿼리 수 최적화: v3
    - 조인이 필요한 경우 쿼리 횟수를 최적화
    - 컬렉션은 페치 조인 시 페이징 불가능
  - 컬렉션 페이징과 한계 돌파: v3.1
    - ToOne 관계는 페치 조인으로 쿼리 수 최적화
    - 컬렉션은 페치 조인 대신에 지연 로딩을 유지하고, ```hibernate.default_batch_fetch_size```, ```@BatchSize```로 최적화
- DTO 직접 조회
  - JPA에서 DTO를 직접 조회: v4
    - 컬렉션 데이터 조회 시 1:N으로 매핑 되어서 데이터 뻥튀기
  - 컬렉션 조회 최적화 - 일대다 관계인 컬렉션은 IN 절을 활용해서 메모리에 미리 조회해서 최적화: v5
  - 플랫 데이터 최적화 - Join 결과를 그대로 조회 후 어플리케이션에서 원하는 모양으로 직접 변환: v6

### 권장 순서

1. 엔티티 조회 방식으로 우선 접근
   1. 페치 조인으로 쿼리 수를 최적화
   2. 컬렉션 최적화
      1. 페이징 필요 ```hibernate.default_batch_fetch_size```, ```@BatchSize```로 최적화
      2. 페이징 필요 x -> 페치 조인 사용
2. 엔티티 조회 방식으로 해결이 안되면 DTO 조회 방식 사용
3. DTO 조회 방식으로도 해결이 안되면 NativeSQL | Spring Jdbc Template

#### 참고

> 엔티티 조회 방식은 페치 조인이나, ```hibernate.default_batch_fetch_size```, ```@BatchSize``` 같이  
> 코드를 거의 수정하지 않고, 옵션만 조금 변경해서, 다양한 성능 최적화를 시도할 수 있다.  
> 반면, DTO를 직접 조회하는 방식은 성능을 최적화 하거나 성능 최적화 방식을 변경할 때 많은 코드의 변경이 필요

#### 참고

> 개발자는 성능 최적화와 코드 복잡도 사이에서 적당한 타협이 필요  
> 보통 성능 최적화 시 단순한 코드가 복잡해지는 경우가 빈번하다.  
> 엔티티 조회 방식은 JPA가 많은 부분을 최적화 해주기 때문에, 단순한 코드를 유지하면서 성능을 최적화 할 수 있다.  
> 반면에 DTO 조회 방식은 SQL을 직접 다루는 것과 유사하기 때문에 엔티티 조회와 dto 조회 사이에 타협이 필요.

### DTO 조회 방식의 선택지
- DTO로 조회하는 방법도 장단이 있다. 단순하게 쿼리가 적게 나갔다고 해서 무조건 좋은 방법은 x
  - 코드 단순
  - 특정 주문 한건만 조회할 경우 성능 좋음
  - 단 데이터가 N건 나올 경우 N + 1 문제가 발생
- v5
  - 코드 복잡
  - 여러 주문을 한꺼번에 조회하는 경우 사용
  - 쿼리 2번으로 해결
- v6
  - v4, v5와는 다른 방식의 접근
  - 조회할 데이터를 전부 조인해서 한 번에 어플리케이션으로 가져와서 핸들링
  - 데이터가 많으면 뻥튀기 되는 데이터가 많아 v5와 비슷한 성능
  - Order를 기준으로 페이징이 불가능 하다는 치명적인 단점 때문에 실무에서 사용하기 힘듦